# Ralph Progress Log
Started: 2026-01-15
Project: opencode-visual-toolkit
---

## Codebase Patterns
- Use `tool()` helper from @opencode-ai/plugin for all tool definitions
- Import from subpath: `import { tool } from '@opencode-ai/plugin/tool'` (not from root)
- Tool args use `tool.schema.*` (which is zod) with `as const` for type inference
- Add explicit `ToolDefinition` type annotation to tools to prevent TS errors
- Zod version must match plugin's (4.1.8)
- Tool execute() returns string (user message), not throws for errors
- Use Sharp for all image resize/crop/optimize operations
- Save all generated assets to `./generated-assets/` by default
- iOS icons go to `AppIcon.appiconset/` with `Contents.json`
- Android icons go to `mipmap-{density}/` with `ic_launcher.xml`
- Always generate 1024x1024 master first, then downscale (never upscale)
- Direct Gemini API calls only - no intermediary services
- @google/genai: Use `GoogleGenAI({ apiKey })` constructor, access via `client.models.generateContent()`
- Gemini responses: Access `result.candidates[0].content.parts` directly for image/text data
- Image data in Gemini: Use `inlineData: { data: base64, mimeType }` format
- Always add TypeScript null checks for optional API response fields
- For AI-guided operations: Always provide fallback behavior when AI fails
- Use regex to extract JSON from Gemini responses: `analysis.match(/\{[^}]+\}/)`
- Cross-platform tools: Create unified types to handle iOS and Android consistently
- Device-specific outputs: Use directory structure `outputDir/platform/device-name/`

---


## 2026-01-15 12:15 - SETUP-002
- Implemented GeminiProvider class with full Google Gemini API integration
- Files changed: 
  - src/providers/gemini.ts (new) - Main provider implementation
  - src/utils/file-handler.ts (new) - File operations for images
  - src/utils/image-processing.ts (new) - Sharp-based image processing
- **Learnings for future iterations:**
  - The @google/genai package exports `GoogleGenAI` class, not `GoogleGenerativeAI`
  - Constructor takes options object: `new GoogleGenAI({ apiKey })`
  - Use `client.models.generateContent()` for all operations (generation, editing, analysis)
  - Response object IS the `GenerateContentResponse` - access `result.candidates` directly
  - For image generation, set `config.responseModalities: ['image']` in request
  - For image input, use `inlineData: { data: base64, mimeType }` in parts array
  - Extract image from `candidate.content.parts[].inlineData.data` (base64 string)
  - Extract text from `candidate.content.parts[].text`
  - Always add proper TypeScript null checks for optional fields
  - Prefix unused parameters with underscore to avoid TS6133 errors
---
## 2026-01-15 13:45 - SETUP-003
- Verified file-handler.ts implementation (already completed in SETUP-002)
- Files changed:
  - prd.json - Marked SETUP-003 as passes: true
- **Learnings for future iterations:**
  - File handler was implemented alongside GeminiProvider in SETUP-002
  - All acceptance criteria met: saveImage, loadImage, ensureDirectory, generateFilename, getOutputDir
  - Duplicate handling implemented via internal getUniqueFilepath() function
  - Uses fs/promises for async file operations
  - Sanitization: limits to 50 chars, replaces spaces with underscores, removes special chars
  - Default output dir: './generated-assets' (overridable via OUTPUT_DIR env var)
---

## 2026-01-15 13:50 - SETUP-004
- Verified image-processing.ts implementation (already completed in SETUP-002)
- Files changed:
  - prd.json - Marked SETUP-004 as passes: true
- **Learnings for future iterations:**
  - Image processing uses Sharp library for all transformations
  - All acceptance criteria met: resize, crop, optimize, convertFormat, getMetadata, resizeToSizes
  - resize() supports fit modes: cover, contain, fill, inside, outside
  - crop() uses Sharp's extract() method with CropRegion interface
  - optimize() defaults to quality 80 with PNG compression level 9
  - convertFormat() supports PNG, JPEG, WebP with quality parameter
  - getMetadata() returns comprehensive info: dimensions, format, space, channels, hasAlpha
  - resizeToSizes() uses Promise.all for concurrent batch processing
---

## 2026-01-15 12:25 - CORE-001
- Implemented generate_image tool - first OpenCode tool in the project
- Files changed:
  - src/tools/core/generate-image.ts (new) - Generate image tool implementation
  - package.json - Added @opencode-ai/plugin dependency, upgraded zod to 4.1.8
  - prd.json - Marked CORE-001 as passes: true
- **Learnings for future iterations:**
  - @opencode-ai/plugin must be imported from subpath '/tool' due to missing `.js` extensions in dist/index.js
  - Use `import { tool } from '@opencode-ai/plugin/tool'` instead of from root
  - Tool args must use `tool.schema` (which is zod) and be marked with `as const` for proper TypeScript inference
  - Zod version must match plugin's version (4.1.8) to avoid module resolution conflicts
  - Add explicit `ToolDefinition` type annotation to prevent TypeScript errors about inferred types
  - Tool parameters automatically get Zod validation from the args schema
  - execute() function parameters are auto-typed from the schema (args, _context)
  - Return string from execute() to display message to user
  - Error handling should return user-friendly strings, not throw
---
## 2026-01-15 14:00 - CORE-002
- Implemented edit_image tool for natural language image editing
- Files changed:
  - src/tools/core/edit-image.ts (new) - Edit image tool implementation
  - prd.json - Marked CORE-002 as passes: true
- **Learnings for future iterations:**
  - GeminiProvider.editImage() was already implemented in SETUP-002 phase
  - Tool follows same pattern as generate_image: tool() helper, args schema, error handling
  - Uses loadImage() to read source file, editImage() for Gemini processing, saveImage() for output
  - Output filename uses '_edited' suffix to distinguish from source
  - Parse source path to extract base filename before appending suffix
  - Error handling covers three cases: missing API key, file load failures, Gemini errors
  - All tool execution returns strings (user messages), never throws
---
## 2026-01-15 14:30 - CORE-003
- Implemented restore_image tool for image restoration and enhancement
- Files changed:
  - src/tools/core/restore-image.ts (new) - Restore image tool implementation
  - prd.json - Marked CORE-003 as passes: true
- **Learnings for future iterations:**
  - Image restoration is implemented using GeminiProvider.editImage() method with restoration prompts
  - Default restoration instruction: 'restore and enhance this image'
  - Can accept custom instructions for specific restoration needs (e.g., "remove scratches", "enhance colors")
  - Follows same error handling pattern as edit-image tool
  - Uses '_restored' suffix for output filenames to distinguish from source
  - Tool pattern remains consistent: load → process with Gemini → save with suffix
  - All quality checks pass (typecheck, lint) - tests not yet implemented (TEST-001/TEST-002 pending)
---
## 2026-01-15 15:00 - PLATFORM-001
- Implemented iOS platform specifications module with complete icon and screenshot sizes
- Files changed:
  - src/platforms/ios.ts (new) - iOS platform specifications
  - prd.json - Marked PLATFORM-001 as passes: true
- **Learnings for future iterations:**
  - iOS requires 18+ icon sizes covering iPhone, iPad, App Store, notifications, settings, spotlight
  - Icon sizes defined by: size (points), scale (1x/2x/3x), pixels (actual), idiom (device type), filename
  - IOS_ICON_SIZES: 18 core sizes for iPhone/iPad (20pt-1024pt at various scales)
  - WATCHOS_ICON_SIZES: 11 sizes for Apple Watch (24pt-1024pt for different watch sizes)
  - CARPLAY_ICON_SIZES: 2 sizes for CarPlay (60pt at 2x/3x)
  - Screenshot sizes based on native resolutions: 6.9", 6.7", 6.3", 6.1", 5.5" iPhones + iPads
  - generateContentsJson() creates Xcode Contents.json with images array and metadata
  - getIconFilename() generates standardized filenames based on platform conventions
  - Pattern: Icon-{Platform}-{size}x{size}@{scale}x.png (e.g., Icon-App-60x60@2x.png)
  - This module will be used by APP-001 (Generate App Icon Tool) to resize master icon
---
## 2026-01-15 16:00 - PLATFORM-002
- Implemented Android platform specifications module with complete density buckets and helpers
- Files changed:
  - src/platforms/android.ts (new) - Android platform specifications
  - prd.json - Marked PLATFORM-002 as passes: true
- **Learnings for future iterations:**
  - Android uses density buckets: mdpi (1x), hdpi (1.5x), xhdpi (2x), xxhdpi (3x), xxxhdpi (4x)
  - Launcher icons: 48dp base size scaled by density (48px @ mdpi up to 192px @ xxxhdpi)
  - All icons go to mipmap-{density}/ directories (e.g., mipmap-hdpi, mipmap-xxxhdpi)
  - Standard launcher icon filename: ic_launcher.png
  - Adaptive icons (API 26+) require foreground and background layers in XML
  - XML goes to res/mipmap-anydpi-v26/ic_launcher.xml with drawable references
  - Android 13+ supports monochrome layer for themed icons (optional third layer)
  - Screenshot sizes based on aspect ratios: 16:9, 18:9, 19:9, 20:9 for phones, tablets at 7"/10"
  - Adaptive icon specs: 108dp full size, 72dp visible, 66dp safe zone for important content
  - Helper functions: getDensityPath(), getIconSizeForDensity(), dpToPixels() for conversions
  - This module will be used by APP-001 (Generate App Icon Tool) for Android icon generation
---
## 2026-01-15 17:00 - APP-001
- Implemented generate_app_icon tool for iOS and Android platforms
- Files changed:
  - src/tools/app-assets/app-icon.ts (new) - Complete app icon generation tool
  - prd.json - Marked APP-001 as passes: true
- **Learnings for future iterations:**
  - App icon generation follows pattern: generate 1024x1024 master → downscale to all platform sizes
  - Never upscale images - always generate largest size first, then downscale for quality
  - iOS icons require AppIcon.appiconset/ directory structure with Contents.json metadata
  - Contents.json must include: images array (filename, idiom, scale, size) + info object (author, version)
  - Android icons go to mipmap-{density}/ directories (mdpi through xxxhdpi)
  - Android adaptive icons require mipmap-anydpi-v26/ic_launcher.xml with foreground/background references
  - Tool schema: define args separately with .describe() for descriptions, not inline objects
  - Extract args with defaults: `const { param = defaultValue } = args` handles optional parameters
  - Use platforms.includes('ios') and platforms.includes('android') to check array membership
  - Tool returns user-friendly message strings, not objects or throws
  - For batch operations (multiple icon sizes), use Promise.all or sequential loops as appropriate
  - This pattern will be reused for screenshots (APP-002), launch images (APP-005), and other asset tools
---
## 2026-01-15 18:00 - APP-002
- Implemented generate_app_screenshots tool for App Store screenshot generation
- Files changed:
  - src/tools/app-assets/screenshots.ts (new) - Complete screenshot generation tool
  - prd.json - Marked APP-002 as passes: true
- **Learnings for future iterations:**
  - Screenshot generation supports two distinct modes: 'image' (resize existing) and 'code' (Gemini generation)
  - For 'image' mode: Load source image, resize to each device dimension using Sharp with 'cover' fit
  - For 'code' mode: Generate device-specific screenshots via Gemini with dimension-aware prompts
  - IOS_SCREENSHOT_SIZES from ios.ts provides all device dimensions (iPhone + iPad)
  - Filter screenshots by platform: check device.includes('iPhone') for iOS, device.includes('iPad') for iPads
  - Filter by device names: match against the 'name' property (e.g., '6.9-inch', 'iPad-12.9')
  - Output structure: screenshots/{device-name}/screenshot-{device-name}.png for organization
  - Use 'cover' fit mode to fill screen without letterboxing - better for App Store previews
  - Gemini aspect ratio mapping: portrait screenshots use '9:16', landscape use '16:9'
  - Tool pattern: filterByPlatform() and filterByDevices() utility functions for size selection
  - Device frames (addDeviceFrame param) prepared for future enhancement but not yet implemented
  - Always ensure device-specific directories exist before saving screenshots
  - This pattern extends the platform module approach used in APP-001 (app icons)
---
## 2026-01-15 19:00 - APP-003
- Implemented resize_for_devices tool with three intelligent crop modes
- Files changed:
  - src/tools/app-assets/resize-devices.ts (new) - Complete smart resize tool
  - prd.json - Marked APP-003 as passes: true
- **Learnings for future iterations:**
  - Three crop modes address different use cases: fit (letterbox), fill (crop to fill), smart (AI-guided)
  - Smart mode uses GeminiProvider.analyzeImage() to identify important content regions
  - Unified screenshot size type helps handle both iOS and Android sizes consistently
  - Created unifyIOSSize() and unifyAndroidSize() converters for cross-platform handling
  - Smart crop prompts Gemini to return JSON with crop coordinates {left, top, width, height}
  - Extract JSON from Gemini response using regex - handles markdown code blocks
  - Fallback to center crop if AI analysis fails (no API key or parsing errors)
  - calculateSmartCrop() validates and constrains returned regions to image boundaries
  - Use getMetadata() to check source dimensions before cropping decisions
  - Smart crop should maintain target aspect ratio while capturing important content
  - For each device: create platform/device-specific directory structure (outputDir/platform/device-name/)
  - Track smart crop warnings separately - don't fail entire operation if AI unavailable for some devices
  - Filter functionality: filterSizes() handles platform and screenshotType combinations
  - Android device names need normalization: replace spaces with hyphens, convert to lowercase
  - Crop mode "fit" uses Sharp's contain (letterbox), "fill" uses cover (crop), "smart" uses extract then fill
  - This tool pattern (AI-assisted image processing) is reusable for other advanced image tools
---
## 2026-01-15 20:00 - APP-004
- Implemented generate_device_mockup tool for placing screenshots in realistic device frames
- Files changed:
  - src/tools/app-assets/device-mockup.ts (new) - Complete device mockup generation tool
  - prd.json - Marked APP-004 as passes: true
- **Learnings for future iterations:**
  - Device mockup uses Gemini's editImage() method to composite screenshots into AI-generated device frames
  - Defined comprehensive device specifications (DEVICE_SPECS) for iPhone 15/16 series and iPads
  - Each device spec includes: displaySize, aspectRatio, and family for proper prompt generation
  - Supported devices: iphone-16-pro-max, iphone-16-pro, iphone-16-plus, iphone-16, iphone-15-pro-max, iphone-15-pro, iphone-15-plus, iphone-15, ipad-pro-12.9, ipad-pro-11, ipad-air, ipad-mini
  - Color validation is soft - accepts any color string for flexibility (common: silver, black, gold, titanium, blue, pink, etc.)
  - Orientation options: portrait or landscape
  - buildMockupPrompt() helper creates detailed prompts describing device characteristics:
    - For iPhone Pro models: Dynamic Island, titanium frame, rounded corners, volume/power buttons
    - For standard iPhone models: Notch, aluminum frame, rounded corners
    - For iPads: Thin aluminum bezel, minimal bezels, flat edges (Pro models)
  - Prompt includes lighting, shadows, screen glare, and composition requirements for professional marketing quality
  - customOutputPath parameter allows user-specified save location, otherwise defaults to mockups/{device}-mockup.png
  - Helper function pattern: Extract buildMockupPrompt() as standalone function, not tool method
  - Tool error handling pattern remains consistent: try-catch with user-friendly error messages
  - This AI-powered compositing approach is different from traditional image overlays - Gemini generates the entire mockup scene
  - Output suitable for App Store marketing materials and promotional content
---
## 2026-01-15 21:00 - APP-005
- Implemented generate_launch_images tool for splash screen generation
- Files changed:
  - src/tools/app-assets/launch-images.ts (new) - Complete launch images tool
  - prd.json - Marked APP-005 as passes: true
- **Learnings for future iterations:**
  - Launch images (splash screens) use same dimensions as screenshots (IOS_SCREENSHOT_SIZES, ANDROID_SCREENSHOT_SIZES)
  - Tool supports two input modes: text description (prompt) or existing image path
  - isFilePath() helper detects file paths by checking for path separators or image extensions
  - Optimization: Group sizes by aspect ratio (9:16 portrait, 16:9 landscape) to minimize Gemini API calls
  - Generate one master image per aspect ratio at largest size in group, then downscale to all other sizes
  - This reduces Gemini API calls from N device sizes down to 2 calls (portrait + landscape)
  - For image mode: Load source once, then resize to all target sizes using Sharp 'cover' fit
  - Output structure: outputDir/platform/launch-{device-name}.png for organization
  - Similar to screenshots, but simpler (no device frame option, always cover fit)
  - Prompt engineering for splash screens: Emphasize "clean, minimal, centered" design suitable for loading screens
  - Include aspect ratio and orientation in prompt to guide Gemini's composition
  - Always validate that Gemini returns at least one image before attempting resize operations
  - TypeScript null checks: Filter array first, then check [0] exists before using path.dirname()
  - Tool pattern remains consistent with other app asset tools: validate input → process → save → return user message
  - This completes the core app asset generation suite (icons, screenshots, device mockups, launch images)
---
## 2026-01-15 22:00 - ANALYZE-001
- Implemented analyze_screenshot tool for UI debugging via visual analysis
- Files changed:
  - src/tools/analyze/screenshot.ts (new) - Complete screenshot analysis tool
  - prd.json - Marked ANALYZE-001 as passes: true
- **Learnings for future iterations:**
  - Screenshot analysis uses GeminiProvider.analyzeImage() method with detailed UI analysis prompt
  - Default analysis prompt covers five key areas: components, layout, accessibility, visual bugs, improvements
  - Optional question parameter allows users to focus analysis on specific concerns
  - Tool pattern remains consistent: load image → analyze with Gemini → return formatted analysis string
  - Comprehensive error handling: API key missing, file not found, general errors
  - Analysis response formatted with checkmark, path, and full Gemini analysis
  - Default prompt structure helps ensure consistent, actionable analysis results
  - This is the first of three analyze tools - sets pattern for ANALYZE-002 (compare) and ANALYZE-003 (mockup)
  - All quality checks pass (typecheck, lint) - tool ready for integration
---
## 2026-01-15 23:00 - ANALYZE-002
- Implemented compare_screenshots tool for visual regression detection
- Files changed:
  - src/tools/analyze/compare.ts (new) - Complete screenshot comparison tool
  - src/providers/gemini.ts (modified) - Added analyzeMultipleImages() method
  - prd.json - Marked ANALYZE-002 as passes: true
- **Learnings for future iterations:**
  - Multi-image comparison requires GeminiProvider.analyzeMultipleImages() method
  - analyzeMultipleImages() sends multiple images in a single Gemini API request
  - Build parts array by adding all images first (as inlineData), then the prompt text last
  - Gemini can compare multiple images and identify visual differences in one analysis
  - Optional highlightDifferences parameter generates a visual diff image via editImage()
  - Diff generation uses Gemini to create side-by-side comparison with red/pink highlights
  - Fallback error handling: If diff generation fails, still return comparison analysis
  - Use getOutputDir() to get default output directory for saving diff images
  - saveImage() requires non-optional outputDir parameter (string, not undefined)
  - Tool pattern: load both images → analyze with multi-image → optionally generate diff → save
  - Multi-image analysis is useful for any comparison task (before/after, A/B testing, regression detection)
  - This completes the second of three analyze tools (screenshot, compare, mockup pending)
  - All quality checks pass (typecheck, lint) - ready for integration
---
## 2026-01-15 23:30 - ANALYZE-003
- Implemented analyze_mockup tool for design specification extraction
- Files changed:
  - src/tools/analyze/mockup.ts (new) - Complete mockup analysis tool
  - prd.json - Marked ANALYZE-003 as passes: true
- **Learnings for future iterations:**
  - Design mockup analysis extracts four key categories: Component Structure, Typography, Color Palette, Spacing & Layout
  - Conditional prompt building: Helper function buildDesignAnalysisPrompt() constructs prompt based on extractColors/extractSpacing flags
  - Always include core features (components, typography) while making colors/spacing optional via boolean parameters
  - Prompt structure guides Gemini to return actionable, developer-friendly values (hex codes, px/rem measurements, font families)
  - Design system context is crucial: prompt asks for overall style, patterns, and responsive considerations
  - Tool follows analyze pattern: load image → analyze with comprehensive prompt → return formatted specs
  - extractColors parameter (default: true) enables/disables color palette extraction
  - extractSpacing parameter (default: true) enables/disables spacing and layout measurements
  - Tool is perfect for design-to-code workflows - extracts specs developers need to implement designs
  - This completes the analyze tool suite: screenshot (UI debugging), compare (regression), mockup (design specs)
  - All quality checks pass (typecheck, lint) - ready for integration
---
## 2026-01-15 23:45 - DESIGN-001
- Implemented mockup_to_code tool for design-to-code conversion
- Files changed:
  - src/tools/design/mockup-to-code.ts (new) - Complete mockup to code tool
  - prd.json - Marked DESIGN-001 as passes: true
- **Learnings for future iterations:**
  - Design-to-code tools use GeminiProvider.analyzeImage() with framework-specific prompts
  - Four supported frameworks: React, Vue, SwiftUI, HTML with different coding patterns
  - Three styling systems: Tailwind, CSS (modules/scoped), styled-components
  - Framework-specific prompt engineering is critical for quality code generation
  - React: TypeScript interfaces, functional components, JSX with className
  - Vue: Composition API, <script setup>, <template>, <style scoped>
  - SwiftUI: View protocol, body computed property, VStack/HStack modifiers
  - HTML: Semantic HTML5, BEM naming, custom CSS or Tailwind classes
  - buildCodeGenerationPrompt() helper constructs framework-aware prompts
  - Separate prompt builders: generateReactPrompt(), generateVuePrompt(), generateSwiftUIPrompt(), generateHTMLPrompt()
  - Prompt structure includes: base analysis (layout, colors, spacing) + framework-specific patterns
  - componentName parameter allows custom naming, falls back to framework defaults
  - Default names: DesignComponent (React/Vue), DesignView (SwiftUI), design-component (HTML)
  - Gemini can generate production-ready code with proper structure, types, and accessibility
  - Tool pattern: load mockup → analyze with framework prompt → return formatted code string
  - User-facing message includes framework, styling, component name for context
  - Styling defaults: React→tailwind, Vue→css, HTML→css (SwiftUI has no styling param)
  - Always include note about reviewing/adjusting code for project-specific requirements
  - This tool bridges design and development, accelerating UI implementation
  - Tool definition pattern: no 'name' property, export const with ToolDefinition type, async execute
  - All quality checks pass (typecheck, lint) - ready for integration
---
